<html><head><base href="https://tetris-mobile-enhanced.example.com/">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Tetris Móvil Mejorado</title>
<style>
  body {
    margin: 0;
    padding: 0;
    background-color: #000;
    color: #0f0;
    font-family: 'Press Start 2P', cursive;
    touch-action: manipulation;
    overflow: hidden;
  }
  h1, h2 {
    text-align: center;
    width: 100%;
  }
  #game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    height: 100vh;
    padding: 10px;
  }
  #game-board {
    position: relative;
    border: 2px solid #0f0;
    box-shadow: 0 0 10px #0f0, 0 0 20px #0f0, 0 0 30px #0f0;
    margin: 40px auto 20px;
  }
  .cell {
    position: absolute;
    box-sizing: border-box;
    border: 1px solid rgba(15, 255, 15, 0.3);
  }
  .ghost-cell {
    position: absolute;
    box-sizing: border-box;
    border: 2px solid rgba(15, 255, 15, 0.5);
    opacity: 0.3;
  }
  #score, #moves, #elapsed-time {
    position: absolute;
    left: 10px;
    font-size: 14px;
    text-shadow: 0 0 5px #0f0;
  }
  #score { top: 10px; }
  #moves { top: 30px; }
  #elapsed-time { top: 50px; }
  #return-to-menu-btn {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    background: transparent;
    border: 2px solid #0f0;
    color: #0f0;
    padding: 5px 10px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
    font-family: 'Press Start 2P', cursive;
  }
  #return-to-menu-btn:hover {
    background-color: rgba(0, 255, 0, 0.2);
    color: #fff;
  }
  #next-piece {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 80px;
    height: 80px;
    border: 2px solid #0f0;
    box-shadow: 0 0 10px #0f0;
  }
  .control-btn {
    width: 60px;
    height: 60px;
    background-color: #000;
    border: 2px solid #0f0;
    color: #0f0;
    font-size: 24px;
    display: flex;
    justify-content: center;
    align-items: center;
    touch-action: manipulation;
    transition: all 0.3s;
  }
  .control-btn:active {
    background-color: #0f0;
    color: #000;
  }
  #drop-btn {
    background-color: #000;
    border-color: #f00;
    color: #f00;
  }
  #drop-btn:active {
    background-color: #f00;
    color: #000;
  }
  #game-over {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 100;
    display: none;
  }
  #game-over h1 {
    font-size: 36px;
    margin-bottom: 20px;
    color: #f00;
    text-shadow: 0 0 10px #f00;
  }
  #game-over p {
    font-size: 18px;
    margin-bottom: 30px;
    color: #0f0;
    text-shadow: 0 0 5px #0f0;
  }
  #restart-btn {
    padding: 10px 20px;
    font-size: 18px;
    background-color: #000;
    color: #0f0;
    border: 2px solid #0f0;
    cursor: pointer;
    font-family: 'Press Start 2P', cursive;
    transition: all 0.3s;
  }
  #restart-btn:hover {
    background-color: #0f0;
    color: #000;
  }
  #controls {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    justify-content: center;
    width: 100%;
    max-width: 300px;
  }
  .full-screen-menu {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  .menu-btn {
    margin: 10px;
    padding: 10px 20px;
    font-size: 18px;
    background-color: #000;
    color: #0f0;
    border: 2px solid #0f0;
    cursor: pointer;
    font-family: 'Press Start 2P', cursive;
    transition: all 0.3s;
  }
  .menu-btn:hover {
    background-color: #0f0;
    color: #000;
  }
  .retro-bg {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: hidden;
    z-index: -1;
  }
  .retro-bg::before {
    content: "";
    position: absolute;
    width: 200%;
    height: 200%;
    top: -50%;
    left: -50%;
    background-image: 
      linear-gradient(0deg, transparent 24%, rgba(15, 255, 15, .05) 25%, rgba(15, 255, 15, .05) 26%, transparent 27%, transparent 74%, rgba(15, 255, 15, .05) 75%, rgba(15, 255, 15, .05) 76%, transparent 77%, transparent),
      linear-gradient(90deg, transparent 24%, rgba(15, 255, 15, .05) 25%, rgba(15, 255, 15, .05) 26%, transparent 27%, transparent 74%, rgba(15, 255, 15, .05) 75%, rgba(15, 255, 15, .05) 76%, transparent 77%, transparent);
    background-size: 50px 50px;
    animation: bgScroll 20s linear infinite;
  }
  @keyframes bgScroll {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  @media (max-width: 768px) {
    #game-container {
      justify-content: flex-start;
      padding-top: 60px;
    }
  }
</style>
</head>
<body>
<div class="retro-bg"></div>
<div id="game-container">
  <button id="return-to-menu-btn" class="menu-btn">Menu</button>
  <div id="game-board"></div>
  <div id="score">Score: 0</div>
  <div id="moves">Moves: 0</div>
  <div id="elapsed-time">Time: 00:00</div>
  <div id="next-piece"></div>
  <div id="controls">
    <button class="control-btn" id="left-btn">←</button>
    <button class="control-btn" id="rotate-btn">↻</button>
    <button class="control-btn" id="down-btn">↓</button>
    <button class="control-btn" id="right-btn">→</button>
    <button class="control-btn" id="drop-btn">⤓</button>
  </div>
  <div id="game-over">
    <h1>Game Over</h1>
    <p id="final-score"></p>
    <button id="restart-btn">Restart</button>
  </div>
</div>
<div id="main-menu" class="full-screen-menu" style="display: none;">
  <h1 id="menu-title">Tetris Móvil Mejorado</h1>
  <button id="play-btn" class="menu-btn">Jugar</button>
  <button id="settings-btn" class="menu-btn">Ajustes</button>
  <button id="high-scores-btn" class="menu-btn">Puntuaciones</button>
</div>
<div id="settings-menu" class="full-screen-menu" style="display: none;">
  <h2 id="settings-title">Ajustes</h2>
  <div class="setting-group">
    <label id="language-label" for="language-select">Idioma:</label>
    <select id="language-select">
      <option value="es">Español</option>
      <option value="en">English</option>
    </select>
  </div>
  <div class="setting-group">
    <label id="color-label">Colores de piezas:</label>
    <div id="color-pickers"></div>
  </div>
  <button id="save-settings-btn" class="menu-btn">Guardar</button>
  <button id="back-btn" class="menu-btn">Volver</button>
</div>
<div id="high-scores-menu" class="full-screen-menu" style="display: none;">
  <h2 id="high-scores-title">Puntuaciones más altas</h2>
  <ol id="high-scores-list"></ol>
  <button id="back-from-scores-btn" class="menu-btn">Volver</button>
</div>
<script>
const COLS = 10;
const ROWS = 20;
let CELL_SIZE = Math.min(window.innerWidth / COLS, (window.innerHeight - 100) / ROWS);
const COLORS = ['#00ff00', '#00ffff', '#ff00ff', '#ffff00', '#ff0000', '#0000ff', '#ffa500'];

let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
let score = 0;
let moves = 0;
let currentPiece = null;
let nextPiece = null;
let ghostPiece = null;
let gameInterval;
let startTime;
let elapsedTimeInterval;
let currentLanguage = 'es';
let highScores = [];

const pieces = [
  [[1, 1, 1, 1]],
  [[1, 1], [1, 1]],
  [[1, 1, 1], [0, 1, 0]],
  [[1, 1, 1], [1, 0, 0]],
  [[1, 1, 1], [0, 0, 1]],
  [[1, 1, 0], [0, 1, 1]],
  [[0, 1, 1], [1, 1, 0]],
  [[1, 1, 1, 1], [0, 0, 0, 1]],
  [[1, 1, 1], [1, 0, 1]],
  [[1, 0, 0], [1, 1, 1]],
  [[0, 0, 1], [1, 1, 1]],
  [[1, 1], [1, 0], [1, 0]],
  [[1, 1], [0, 1], [0, 1]],
  [[1, 0], [1, 1], [0, 1]],
  [[0, 1], [1, 1], [1, 0]]
];

let pieceHistory = [];

function createPiece() {
  let pieceIndex;
  do {
    pieceIndex = Math.floor(Math.random() * pieces.length);
  } while (pieceHistory.includes(pieceIndex));

  pieceHistory.push(pieceIndex);
  if (pieceHistory.length > 5) {
    pieceHistory.shift();
  }

  const piece = pieces[pieceIndex];
  const color = COLORS[Math.floor(Math.random() * COLORS.length)];
  return { shape: piece, color: color, row: 0, col: Math.floor(COLS / 2) - Math.ceil(piece[0].length / 2) };
}

function drawBoard() {
  const gameBoard = document.getElementById('game-board');
  gameBoard.innerHTML = '';
  gameBoard.style.width = `${COLS * CELL_SIZE}px`;
  gameBoard.style.height = `${ROWS * CELL_SIZE}px`;

  for (let row = 0; row < ROWS; row++) {
    for (let col = 0; col < COLS; col++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.style.width = `${CELL_SIZE}px`;
      cell.style.height = `${CELL_SIZE}px`;
      cell.style.left = `${col * CELL_SIZE}px`;
      cell.style.top = `${row * CELL_SIZE}px`;
      
      if (board[row][col]) {
        cell.style.backgroundColor = board[row][col];
      }
      
      gameBoard.appendChild(cell);
    }
  }

  if (ghostPiece) {
    drawPiece(ghostPiece, gameBoard, true);
  }

  if (currentPiece) {
    drawPiece(currentPiece, gameBoard);
  }
}

function drawPiece(piece, container, isGhost = false) {
  piece.shape.forEach((row, rowIndex) => {
    row.forEach((value, colIndex) => {
      if (value) {
        const cell = document.createElement('div');
        cell.className = isGhost ? 'ghost-cell' : 'cell';
        cell.style.width = `${CELL_SIZE}px`;
        cell.style.height = `${CELL_SIZE}px`;
        cell.style.left = `${(piece.col + colIndex) * CELL_SIZE}px`;
        cell.style.top = `${(piece.row + rowIndex) * CELL_SIZE}px`;
        cell.style.backgroundColor = piece.color;
        cell.style.opacity = isGhost ? '0.3' : '1';
        container.appendChild(cell);
      }
    });
  });
}

function drawNextPiece() {
  const nextPieceContainer = document.getElementById('next-piece');
  nextPieceContainer.innerHTML = '';
  const scaleFactor = 80 / (Math.max(nextPiece.shape.length, nextPiece.shape[0].length) * CELL_SIZE);
  
  nextPiece.shape.forEach((row, rowIndex) => {
    row.forEach((value, colIndex) => {
      if (value) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.style.width = `${CELL_SIZE * scaleFactor}px`;
        cell.style.height = `${CELL_SIZE * scaleFactor}px`;
        cell.style.left = `${colIndex * CELL_SIZE * scaleFactor}px`;
        cell.style.top = `${rowIndex * CELL_SIZE * scaleFactor}px`;
        cell.style.backgroundColor = nextPiece.color;
        nextPieceContainer.appendChild(cell);
      }
    });
  });
}

function updateGhostPiece() {
  if (!currentPiece) return;
  
  ghostPiece = {...currentPiece, row: currentPiece.row};
  while (!collision(ghostPiece)) {
    ghostPiece.row++;
  }
  ghostPiece.row--;
}

function moveDown() {
  if (!currentPiece) return;

  currentPiece.row++;
  if (collision(currentPiece)) {
    currentPiece.row--;
    placePiece();
    clearRows();
    currentPiece = nextPiece;
    nextPiece = createPiece();
    drawNextPiece();
    moves++;
    updateMovesDisplay();
    if (collision(currentPiece)) {
      gameOver();
      return;
    }
  }
  updateGhostPiece();
  drawBoard();
}

function moveLeft() {
  currentPiece.col--;
  if (collision(currentPiece)) {
    currentPiece.col++;
  } else {
    moves++;
    updateMovesDisplay();
  }
  updateGhostPiece();
  drawBoard();
}

function moveRight() {
  currentPiece.col++;
  if (collision(currentPiece)) {
    currentPiece.col--;
  } else {
    moves++;
    updateMovesDisplay();
  }
  updateGhostPiece();
  drawBoard();
}

function rotate() {
  const rotated = currentPiece.shape[0].map((_, i) =>
    currentPiece.shape.map(row => row[i]).reverse()
  );
  const previousShape = currentPiece.shape;
  currentPiece.shape = rotated;
  if (collision(currentPiece)) {
    currentPiece.shape = previousShape;
  } else {
    moves++;
    updateMovesDisplay();
  }
  updateGhostPiece();
  drawBoard();
}

function collision(piece) {
  return piece.shape.some((row, rowIndex) =>
    row.some((value, colIndex) => {
      if (!value) return false;
      const newRow = piece.row + rowIndex;
      const newCol = piece.col + colIndex;
      return newRow >= ROWS || newCol < 0 || newCol >= COLS || (board[newRow] && board[newRow][newCol]);
    })
  );
}

function placePiece() {
  currentPiece.shape.forEach((row, rowIndex) => {
    row.forEach((value, colIndex) => {
      if (value) {
        board[currentPiece.row + rowIndex][currentPiece.col + colIndex] = currentPiece.color;
      }
    });
  });
}

function clearRows() {
  let rowsCleared = 0;
  for (let row = ROWS - 1; row >= 0; row--) {
    if (board[row].every(cell => cell !== 0)) {
      board.splice(row, 1);
      board.unshift(Array(COLS).fill(0));
      rowsCleared++;
    }
  }
  if (rowsCleared > 0) {
    score += rowsCleared * 100;
    updateScoreDisplay();
  }
}

function resetGame() {
  clearInterval(gameInterval);
  stopTimer();

  const gameContainer = document.getElementById('game-container');
  const controls = document.getElementById('controls');
  const availableHeight = gameContainer.clientHeight - controls.clientHeight - 40;
  CELL_SIZE = Math.min(
    (gameContainer.clientWidth - 40) / COLS,
    (availableHeight - 100) / ROWS
  );

  board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
  score = 0;
  moves = 0;
  pieceHistory = [];
  currentPiece = createPiece();
  nextPiece = createPiece();
  ghostPiece = null;
  updateGhostPiece();
  updateScoreDisplay();
  updateMovesDisplay();
  drawBoard();
  drawNextPiece();
  document.getElementById('game-over').style.display = 'none';
  startTimer();
  startGame();
  
  document.getElementById('left-btn').disabled = false;
  document.getElementById('right-btn').disabled = false;
  document.getElementById('down-btn').disabled = false;
  document.getElementById('rotate-btn').disabled = false;
  document.getElementById('drop-btn').disabled = false;

  document.getElementById('return-to-menu-btn').style.display = 'block';
  document.getElementById('game-container').style.display = 'flex';
}

function dropPiece() {
  while (!collision(currentPiece)) {
    currentPiece.row++;
  }
  currentPiece.row--;
  placePiece();
  clearRows();
  currentPiece = nextPiece;
  nextPiece = createPiece();
  updateGhostPiece();
  drawNextPiece();
  moves++;
  updateMovesDisplay();
  if (collision(currentPiece)) {
    gameOver();
  }
  drawBoard();
}

function updateScoreDisplay() {
  document.getElementById('score').textContent = 'Score: ' + score;
}

function updateMovesDisplay() {
  document.getElementById('moves').textContent = 'Moves: ' + moves;
}

function updateElapsedTime() {
  const currentTime = new Date().getTime();
  const elapsedSeconds = Math.floor((currentTime - startTime) / 1000);
  const minutes = Math.floor(elapsedSeconds / 60);
  const seconds = elapsedSeconds % 60;
  document.getElementById('elapsed-time').textContent = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

function startTimer() {
  startTime = new Date().getTime();
  elapsedTimeInterval = setInterval(updateElapsedTime, 1000);
}

function stopTimer() {
  clearInterval(elapsedTimeInterval);
}

function gameOver() {
  clearInterval(gameInterval);
  stopTimer();
  document.getElementById('game-over').style.display = 'flex';
  const finalTime = document.getElementById('elapsed-time').textContent.slice(6);
  const finalScoreText = `${currentLanguage === 'es' ? 'Puntuación Final' : 'Final Score'}: ${score} | ${currentLanguage === 'es' ? 'Movimientos' : 'Moves'}: ${moves} | ${currentLanguage === 'es' ? 'Tiempo' : 'Time'}: ${finalTime}`;
  document.getElementById('final-score').textContent = finalScoreText;

  highScores.push({ score, moves, time: finalTime });
  updateHighScores();

  document.getElementById('left-btn').disabled = true;
  document.getElementById('right-btn').disabled = true;
  document.getElementById('down-btn').disabled = true;
  document.getElementById('rotate-btn').disabled = true;
  document.getElementById('drop-btn').disabled = true;

  currentPiece = null;
  nextPiece = null;

  drawBoard();
}

function startGame() {
  if (gameInterval) {
    clearInterval(gameInterval);
  }
  gameInterval = setInterval(moveDown, 1500);
}

function updateLanguage(lang) {
  currentLanguage = lang;
  const translations = {
    es: {
      menuTitle: "Tetris Móvil Mejorado",
      play: "Jugar",
      settings: "Ajustes",
      highScores: "Puntuaciones",
      languageLabel: "Idioma:",
      colorLabel: "Colores de piezas:",
      save: "Guardar",
      back: "Volver",
      highScoresTitle: "Puntuaciones más altas",
      score: "Puntuación",
      moves: "Movimientos",
      time: "Tiempo",
      gameOver: "Juego Terminado",
      finalScore: "Puntuación Final",
    },
    en: {
      menuTitle: "Enhanced Mobile Tetris",
      play: "Play",
      settings: "Settings",
      highScores: "High Scores",
      languageLabel: "Language:",
      colorLabel: "Piece Colors:",
      save: "Save",
      back: "Back",
      highScoresTitle: "Highest Scores",
      score: "Score",
      moves: "Moves",
      time: "Time",
      gameOver: "Game Over",
      finalScore: "Final Score",
    }
  };

  document.getElementById('menu-title').textContent = translations[lang].menuTitle;
  document.getElementById('play-btn').textContent = translations[lang].play;
  document.getElementById('settings-btn').textContent = translations[lang].settings;
  document.getElementById('high-scores-btn').textContent = translations[lang].highScores;
  document.getElementById('settings-title').textContent = translations[lang].settings;
  document.getElementById('language-label').textContent = translations[lang].languageLabel;
  document.getElementById('color-label').textContent = translations[lang].colorLabel;
  document.getElementById('save-settings-btn').textContent = translations[lang].save;
  document.getElementById('back-btn').textContent = translations[lang].back;
  document.getElementById('high-scores-title').textContent = translations[lang].highScoresTitle;
  document.getElementById('back-from-scores-btn').textContent = translations[lang].back;

  document.getElementById('score').textContent = `${translations[lang].score}: 0`;
  document.getElementById('moves').textContent = `${translations[lang].moves}: 0`;
  document.getElementById('elapsed-time').textContent = `${translations[lang].time}: 00:00`;

  document.querySelector('#game-over h1').textContent = translations[lang].gameOver;
  document.querySelector('#game-over p').textContent = `${translations[lang].finalScore}: 0 | ${translations[lang].moves}: 0 | ${translations[lang].time}: 00:00`;
}

function createColorPickers() {
  const colorPickersContainer = document.getElementById('color-pickers');
  COLORS.forEach((color, index) => {
    const input = document.createElement('input');
    input.type = 'color';
    input.value = color;
    input.className = 'color-picker';
    input.addEventListener('change', (e) => {
      COLORS[index] = e.target.value;
    });
    colorPickersContainer.appendChild(input);
  });
}

function updateHighScores() {
  const highScoresList = document.getElementById('high-scores-list');
  highScoresList.innerHTML = '';
  highScores.sort((a, b) => b.score - a.score);
  highScores.slice(0, 10).forEach((score, index) => {
    const li = document.createElement('li');
    li.textContent = `${score.score} pts - ${score.moves} moves - ${score.time}`;
    highScoresList.appendChild(li);
  });
}

document.getElementById('left-btn').addEventListener('touchstart', moveLeft);
document.getElementById('right-btn').addEventListener('touchstart', moveRight);
document.getElementById('down-btn').addEventListener('touchstart', moveDown);
document.getElementById('rotate-btn').addEventListener('touchstart', rotate);
document.getElementById('drop-btn').addEventListener('touchstart', dropPiece);
document.getElementById('restart-btn').addEventListener('click', resetGame);
document.getElementById('return-to-menu-btn').addEventListener('click', () => {
  clearInterval(gameInterval);
  stopTimer();
  document.getElementById('game-container').style.display = 'none';
  document.getElementById('main-menu').style.display = 'flex';
});
document.getElementById('play-btn').addEventListener('click', () => {
  document.getElementById('main-menu').style.display = 'none';
  document.getElementById('game-container').style.display = 'flex';
  document.getElementById('return-to-menu-btn').style.display = 'block';
  resetGame();
});
document.getElementById('settings-btn').addEventListener('click', () => {
  document.getElementById('main-menu').style.display = 'none';
  document.getElementById('settings-menu').style.display = 'flex';
});
document.getElementById('high-scores-btn').addEventListener('click', () => {
  document.getElementById('main-menu').style.display = 'none';
  document.getElementById('high-scores-menu').style.display = 'flex';
  updateHighScores();
});
document.getElementById('save-settings-btn').addEventListener('click', () => {
  document.getElementById('settings-menu').style.display = 'none';
  document.getElementById('main-menu').style.display = 'flex';
});
document.getElementById('back-btn').addEventListener('click', () => {
  document.getElementById('settings-menu').style.display = 'none';
  document.getElementById('main-menu').style.display = 'flex';
});
document.getElementById('back-from-scores-btn').addEventListener('click', () => {
  document.getElementById('high-scores-menu').style.display = 'none';
  document.getElementById('main-menu').style.display = 'flex';
});
document.getElementById('language-select').addEventListener('change', (e) => {
  updateLanguage(e.target.value);
});

createColorPickers();
updateLanguage(currentLanguage);
document.getElementById('main-menu').style.display = 'flex';
resetGame();
</script>
</body></html>