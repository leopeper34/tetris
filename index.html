<html><head><base href="">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tetris WebSim - Menu Button Edition</title>
<style>
  body {
    margin: 0;
    padding: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
    color: #ffffff;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
  }

  #game-container {
    position: relative;
    width: 300px;
    height: 600px;
    border: 4px solid #e94560;
    border-radius: 10px;
    background-color: rgba(0, 0, 0, 0.7);
    box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
  }

  #game-board {
    width: 100%;
    height: 100%;
  }

  .tetromino {
    position: absolute;
    box-sizing: border-box;
    transition: transform 0.1s;
  }

  #score, #timer {
    position: absolute;
    right: 20px;
    font-size: 24px;
    font-weight: bold;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  }

  #score {
    top: 20px;
  }

  #timer {
    top: 60px;
  }

  #next-piece-container {
    position: absolute;
    top: 110px;
    right: 20px;
    width: 100px;
    height: 100px;
    border: 2px solid #e94560;
    border-radius: 5px;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #next-piece {
    width: 80px;
    height: 80px;
  }

  #controls {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 15px;
  }

  .control-btn {
    width: 70px;
    height: 70px;
    background-color: #e94560;
    border: none;
    border-radius: 50%;
    font-size: 28px;
    color: #ffffff;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  }

  .control-btn:hover {
    background-color: #ff6b6b;
    transform: translateY(-2px);
    box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
  }

  .control-btn:active {
    transform: translateY(1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
  }

  #menu-btn {
    position: absolute;
    top: 20px;
    left: 20px;
    padding: 10px 20px;
    font-size: 18px;
    background-color: #4ECDC4;
    color: #ffffff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s;
  }

  #menu-btn:hover {
    background-color: #45B7D1;
    transform: translateY(-2px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
  }

  #menu-btn:active {
    transform: translateY(1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }

  .overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    display: none;
  }

  .menu-content, .settings-content {
    background-color: #1a1a2e;
    padding: 2rem;
    border-radius: 10px;
    text-align: center;
  }

  .menu-btn {
    display: block;
    width: 200px;
    margin: 1rem auto;
    padding: 0.5rem;
    font-size: 1.2rem;
    background-color: #e94560;
    color: #ffffff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s;
  }

  .menu-btn:hover {
    background-color: #ff6b6b;
  }

  #high-score {
    font-size: 1.2rem;
    margin-top: 1rem;
  }

  .setting {
    margin: 1rem 0;
  }

  #color-palette {
    margin-left: 0.5rem;
  }

  @media (min-width: 768px) {
    #controls {
      display: none;
    }
  }

  @keyframes glow {
    0% { box-shadow: 0 0 5px #e94560; }
    50% { box-shadow: 0 0 20px #e94560, 0 0 30px #ff6b6b; }
    100% { box-shadow: 0 0 5px #e94560; }
  }

  .glow {
    animation: glow 1s infinite;
  }

  #music-btn {
    position: absolute;
    top: 60px;
    left: 20px;
    padding: 10px;
    font-size: 18px;
    background-color: #4ECDC4;
    color: #ffffff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s;
  }

  #music-btn:hover {
    background-color: #45B7D1;
    transform: translateY(-2px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
  }

  #music-btn:active {
    transform: translateY(1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .fade-in {
    animation: fadeIn 0.3s ease-in-out;
  }
</style>
</head>
<body>
  <audio id="background-music" loop>
    <source src="https://example.com/tetris-theme.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <div id="menu-overlay" class="overlay">
    <div class="menu-content">
      <h1>Tetris WebSim</h1>
      <button id="play-btn" class="menu-btn">Play</button>
      <button id="settings-btn" class="menu-btn">Settings</button>
      <div id="high-score">High Score: 0</div>
    </div>
  </div>

  <div id="settings-panel" class="overlay">
    <div class="settings-content">
      <h2>Settings</h2>
      <div class="setting">
        <label for="color-palette">Color Palette:</label>
        <select id="color-palette">
          <option value="default">Default</option>
          <option value="pastel">Pastel</option>
          <option value="neon">Neon</option>
        </select>
      </div>
      <div class="setting">
        <label for="music-toggle">Background Music:</label>
        <input type="checkbox" id="music-toggle">
      </div>
      <button id="save-settings" class="menu-btn">Save & Close</button>
    </div>
  </div>

  <div id="game-container">
    <canvas id="game-board"></canvas>
    <div id="score">Score: 0</div>
    <div id="timer">Time: 00:00</div>
    <div id="next-piece-container">
      <canvas id="next-piece"></canvas>
    </div>
    <button id="menu-btn">Menu</button>
    <button id="music-btn">ðŸ”‡</button>
  </div>
  <div id="controls">
    <button class="control-btn" id="left-btn">&#8592;</button>
    <button class="control-btn" id="rotate-btn">&#8635;</button>
    <button class="control-btn" id="right-btn">&#8594;</button>
    <button class="control-btn" id="down-btn">&#8595;</button>
  </div>

<script>
let isAudioLoaded = false;
const canvas = document.getElementById('game-board');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const timerElement = document.getElementById('timer');
const nextPieceElement = document.getElementById('next-piece');
const nextPieceCtx = nextPieceElement.getContext('2d');
const menuBtn = document.getElementById('menu-btn');
const backgroundMusic = document.getElementById('background-music');
const musicBtn = document.getElementById('music-btn');
let isMusicPlaying = false;

const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = 30;

canvas.width = COLS * BLOCK_SIZE;
canvas.height = ROWS * BLOCK_SIZE;

ctx.scale(BLOCK_SIZE, BLOCK_SIZE);

const colorPalettes = {
  default: [
    '#FF6B6B', '#4ECDC4', '#45B7D1', '#F9C74F', 
    '#90BE6D', '#43AA8B', '#577590', '#F94144',
    '#F3722C', '#F8961E', '#F9844A', '#F9C74F',
    '#277DA1', '#4D908E'
  ],
  pastel: [
    '#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF',
    '#FFC6FF', '#BDB2FF', '#A0C4FF', '#9BF6FF', '#CAFFBF'
  ],
  neon: [
    '#FF00FF', '#00FFFF', '#00FF00', '#FFFF00', '#FF0000',
    '#FF1493', '#00FA9A', '#1E90FF', '#FF4500', '#FFD700'
  ]
};

let COLORS = [...colorPalettes.default];

const SHAPES = [
  [[1, 1, 1, 1]],                         
  [[1, 1, 1, 1, 1]],                      
  [[1, 1], [1, 1]],                       
  [[1, 1, 1], [0, 1, 0]],                 
  [[1, 1, 1], [1, 0, 0]],                 
  [[1, 1, 1], [0, 0, 1]],                 
  [[1, 1, 0], [0, 1, 1]],                 
  [[0, 1, 1], [1, 1, 0]],                 
  [[1, 1, 1, 1], [0, 0, 1, 0]],           
  [[1, 1, 1], [1, 0, 1]],                 
  [[1, 1], [1, 0], [1, 0]],               
  [[1, 1, 1], [1, 1, 1], [1, 1, 1]],      
  [[1, 0, 0], [1, 1, 1], [0, 0, 1]]       
];

let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
let score = 0;
let currentPiece = getRandomPiece();
let nextPiece = getRandomPiece();
let dropCounter = 0;
let dropInterval = 800;
let lastTime = 0;
let gameTime = 0;
let gameActive = true;

let highScore = 0;
let currentColorPalette = 'default';

function getRandomPiece() {
  const randomShape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
  const color = COLORS[Math.floor(Math.random() * COLORS.length)];
  return { shape: randomShape, color, row: 0, col: Math.floor(COLS / 2) - Math.ceil(randomShape[0].length / 2) };
}

function getGhostPiecePosition() {
  const ghost = JSON.parse(JSON.stringify(currentPiece));
  while (!collision(ghost)) {
    ghost.row++;
  }
  ghost.row--;
  return ghost;
}

function dropPiece() {
  while (!collision()) {
    currentPiece.row++;
  }
  currentPiece.row--;
  merge();
  clearLines();
  currentPiece = nextPiece;
  nextPiece = getRandomPiece();
  updateNextPieceDisplay();
  if (collision()) {
    gameOver();
  }
}

function drawBoard() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.fillRect(0, 0, COLS, ROWS);

  ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
  ctx.lineWidth = 0.05;

  for (let i = 0; i <= COLS; i++) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, ROWS);
    ctx.stroke();
  }

  for (let i = 0; i <= ROWS; i++) {
    ctx.beginPath();
    ctx.moveTo(0, i);
    ctx.lineTo(COLS, i);
    ctx.stroke();
  }

  board.forEach((row, y) => {
    row.forEach((block, x) => {
      if (block) {
        ctx.fillStyle = COLORS[block.value - 1];
        ctx.globalAlpha = block.isNew ? 0 : 1;
        ctx.fillRect(x, y, 1, 1);
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.strokeRect(x, y, 1, 1);
        ctx.globalAlpha = 1;
        
        if (block.isNew) {
          block.isNew = false;
          animateBlock(x, y);
        }
      }
    });
  });
}

function animateBlock(x, y) {
  let opacity = 0;
  const animationInterval = setInterval(() => {
    opacity += 0.1;
    if (opacity >= 1) {
      clearInterval(animationInterval);
    }
    board[y][x].opacity = opacity;
  }, 30);
}

function merge() {
  currentPiece.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        const blockValue = COLORS.indexOf(currentPiece.color) + 1;
        board[currentPiece.row + y][currentPiece.col + x] = {
          value: blockValue,
          isNew: true
        };
      }
    });
  });
}

function clearLines() {
  let linesCleared = 0;
  board = board.reduce((acc, row) => {
    if (row.every(value => value !== 0)) {
      linesCleared++;
      acc.unshift(Array(COLS).fill(0));
    } else {
      acc.push(row);
    }
    return acc;
  }, []);

  if (linesCleared > 0) {
    score += linesCleared * 100;
    updateScore();
    playLineClearAnimation(linesCleared);
  }
}

function playLineClearAnimation(linesCleared) {
  const gameContainer = document.getElementById('game-container');
  gameContainer.classList.add('glow');
  setTimeout(() => {
    gameContainer.classList.remove('glow');
  }, 500);
}

function updateScore() {
  scoreElement.textContent = 'Score: ' + score;
}

function updateTimer() {
  const minutes = Math.floor(gameTime / 60000);
  const seconds = Math.floor((gameTime % 60000) / 1000);
  timerElement.textContent = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

function updateNextPieceDisplay() {
  nextPieceCtx.clearRect(0, 0, nextPieceElement.width, nextPieceElement.height);
  
  const scale = 20;
  nextPieceCtx.save();
  nextPieceCtx.scale(scale, scale);
  
  const offsetX = (4 - nextPiece.shape[0].length) / 2;
  const offsetY = (4 - nextPiece.shape.length) / 2;
  
  drawPiece(nextPiece, nextPieceCtx, offsetX, offsetY);
  
  nextPieceCtx.restore();
}

function gameOver() {
  gameActive = false;
  updateHighScore();
  showMenu();
}

function restartGame() {
  board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
  score = 0;
  gameTime = 0; 
  dropCounter = 0;
  currentPiece = getRandomPiece();
  nextPiece = getRandomPiece();
  updateScore();
  updateTimer();
  updateNextPieceDisplay();
  dropInterval = 800; 
}

function showMenu() {
  document.getElementById('menu-overlay').style.display = 'flex';
  gameActive = false;
  gameTime = 0; 
  updateTimer(); 
  restartGame(); 
  backgroundMusic.pause();
  musicBtn.textContent = 'ðŸ”‡';
  isMusicPlaying = false;
}

function hideMenu() {
  document.getElementById('menu-overlay').style.display = 'none';
  gameActive = true;
  restartGame(); 
  lastTime = performance.now(); 
  if (isMusicPlaying) {
    safelyPlayAudio();
  }
  requestAnimationFrame(update); 
}

function showSettings() {
  document.getElementById('settings-panel').style.display = 'flex';
  musicToggle.checked = isMusicPlaying;
}

function hideSettings() {
  document.getElementById('settings-panel').style.display = 'none';
}

function updateHighScore() {
  if (score > highScore) {
    highScore = score;
    document.getElementById('high-score').textContent = `High Score: ${highScore}`;
  }
}

function changeColorPalette() {
  currentColorPalette = document.getElementById('color-palette').value;
  COLORS.length = 0;
  colorPalettes[currentColorPalette].forEach(color => COLORS.push(color));
  updateNextPieceDisplay();
}

function safelyPlayAudio() {
  if (isAudioLoaded && !backgroundMusic.paused) {
    return Promise.resolve();
  }
  return backgroundMusic.play().catch(error => {
    console.warn("Audio play failed:", error);
    isMusicPlaying = false;
    musicBtn.textContent = 'ðŸ”‡';
  });
}

const musicToggle = document.getElementById('music-toggle');

musicToggle.addEventListener('change', () => {
  if (musicToggle.checked) {
    safelyPlayAudio().then(() => {
      isMusicPlaying = true;
      musicBtn.textContent = 'ðŸ”Š';
    });
  } else {
    backgroundMusic.pause();
    musicBtn.textContent = 'ðŸ”‡';
    isMusicPlaying = false;
  }
});

backgroundMusic.addEventListener('canplaythrough', () => {
  isAudioLoaded = true;
});

document.addEventListener('keydown', event => {
  if (!gameActive) return;
  
  switch (event.keyCode) {
    case 37: 
      moveLeft();
      break;
    case 39: 
      moveRight();
      break;
    case 40: 
      moveDown();
      break;
    case 38: 
      rotate();
      break;
    case 32: 
      dropPiece();
      break;
  }
});

// Touch controls
document.getElementById('left-btn').addEventListener('click', () => {
  if (gameActive) moveLeft();
});
document.getElementById('right-btn').addEventListener('click', () => {
  if (gameActive) moveRight();
});
document.getElementById('down-btn').addEventListener('click', () => {
  if (gameActive) moveDown();
});
document.getElementById('rotate-btn').addEventListener('click', () => {
  if (gameActive) rotate();
});

// Menu button
menuBtn.addEventListener('click', showMenu);

// Menu buttons
document.getElementById('play-btn').addEventListener('click', () => {
  hideMenu();
  restartGame(); 
});
document.getElementById('settings-btn').addEventListener('click', showSettings);
document.getElementById('save-settings').addEventListener('click', () => {
  changeColorPalette();
  hideSettings();
});

// Music button
musicBtn.addEventListener('click', toggleMusic);

function toggleMusic() {
  if (isMusicPlaying) {
    backgroundMusic.pause();
    musicBtn.textContent = 'ðŸ”‡';
    isMusicPlaying = false;
  } else {
    safelyPlayAudio().then(() => {
      isMusicPlaying = true;
      musicBtn.textContent = 'ðŸ”Š';
    });
  }
}

function collision(piece = currentPiece) {
  return piece.shape.some((row, dy) => {
    return row.some((value, dx) => {
      if (value !== 0) {
        const x = piece.col + dx;
        const y = piece.row + dy;
        return x < 0 || x >= COLS || y >= ROWS || (y >= 0 && board[y][x] !== 0);
      }
      return false;
    });
  });
}

function moveLeft() {
  currentPiece.col--;
  if (collision()) {
    currentPiece.col++;
  }
}

function moveRight() {
  currentPiece.col++;
  if (collision()) {
    currentPiece.col--;
  }
}

function moveDown() {
  currentPiece.row++;
  if (collision()) {
    currentPiece.row--;
    merge();
    clearLines();
    currentPiece = nextPiece;
    nextPiece = getRandomPiece();
    updateNextPieceDisplay();
    if (collision()) {
      gameOver();
    }
  }
  dropCounter = 0;
}

function rotate() {
  const originalShape = currentPiece.shape;
  currentPiece.shape = currentPiece.shape[0].map((_, i) =>
    currentPiece.shape.map(row => row[i]).reverse()
  );
  if (collision()) {
    currentPiece.shape = originalShape;
  }
}

function drawGhostPiece() {
  const ghost = getGhostPiecePosition();
  ctx.globalAlpha = 0.3;
  drawPiece(ghost, ctx);
  ctx.globalAlpha = 1;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBoard();
  drawGhostPiece();
  drawPiece(currentPiece, ctx);
}

function drawPiece(piece, context, offsetX = 0, offsetY = 0) {
  piece.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        context.fillStyle = piece.color;
        context.fillRect(piece.col + x + offsetX, piece.row + y + offsetY, 1, 1);
        context.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        context.strokeRect(piece.col + x + offsetX, piece.row + y + offsetY, 1, 1);
      }
    });
  });
}

// Show the menu when the page loads
window.addEventListener('load', showMenu);

function update(time = 0) {
  if (!gameActive) return;

  const deltaTime = time - lastTime;
  lastTime = time;

  gameTime += deltaTime;
  updateTimer();

  dropCounter += deltaTime;
  if (dropCounter > dropInterval) {
    moveDown();
  }

  draw();
  requestAnimationFrame(update);
}

updateNextPieceDisplay();
update();
</script>
</body>
</html>