<html><head><base href="">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tetris WebSim - Menu Button Edition</title>
<style>
  body {
    margin: 0;
    padding: 10px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
    color: #ffffff;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    box-sizing: border-box;
  }

  #game-container {
    width: 100%;
    max-width: 300px;
    height: auto;
    aspect-ratio: 10 / 22;
    margin-bottom: 20px;
  }

  #game-board {
    width: 100%;
    height: 100%;
  }

  .tetromino {
    position: absolute;
    box-sizing: border-box;
    transition: transform 0.1s;
  }

  #score, #timer, #moves {
    position: absolute;
    right: 10px;
    font-size: 16px;
  }

  #score {
    top: 10px;
  }

  #timer {
    top: 40px;
  }

  #moves {
    top: 70px;
  }

  #next-piece-container {
    position: absolute;
    top: 100px;
    right: 10px;
    width: 80px;
    height: 80px;
    border: 2px solid #e94560;
    border-radius: 5px;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
  }

  #next-piece {
    width: 60px;
    height: 60px;
  }

  #menu-btn {
    position: absolute;
    top: 10px;
    left: 10px;
    padding: 8px 16px;
    font-size: 16px;
    background-color: #4ECDC4;
    color: #ffffff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s;
  }

  #menu-btn:hover {
    background-color: #45B7D1;
    transform: translateY(-2px);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
  }

  #menu-btn:active {
    transform: translateY(1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }

  .overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    display: none;
  }

  .menu-content, .settings-content {
    background-color: #1a1a2e;
    padding: 2rem;
    border-radius: 10px;
    text-align: center;
    width: 100%;
    height: 100%;
    max-width: none;
    max-height: none;
    box-sizing: border-box;
    padding: 5%;
  }

  .menu-btn {
    display: block;
    width: 80%;
    max-width: 300px;
    margin: 1rem auto;
    padding: 1rem;
    font-size: 1.2rem;
    background-color: #e94560;
    color: #ffffff;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s;
  }

  .menu-btn:hover {
    background-color: #ff6b6b;
  }

  #high-score {
    font-size: 1.5rem;
    margin-top: 2rem;
  }

  .setting {
    margin: 1rem 0;
  }

  #controls {
    position: relative;
    display: flex; /* Always display controls on mobile */
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    width: 100%;
    max-width: 300px;
    margin-top: 10px;
  }

  .control-btn {
    width: 40px;
    height: 40px;
    font-size: 16px;
    padding: 0;
  }

  @media (max-width: 767px) {
    body {
      padding: 5px;
    }

    #game-container {
      max-width: 100%;
      max-height: 60vh; /* Reduced from 70vh to 60vh */
    }

    #score, #timer, #moves {
      font-size: 12px; /* Reduced font size */
      right: 5px; /* Moved slightly to the left */
    }

    #score {
      top: 5px;
    }

    #timer {
      top: 22px; /* Adjusted position */
    }

    #moves {
      top: 39px; /* Adjusted position */
    }

    #next-piece-container {
      top: 56px; /* Adjusted position */
      right: 5px;
      width: 50px; /* Reduced size */
      height: 50px;
    }

    #next-piece {
      width: 40px; /* Adjusted size */
      height: 40px;
    }

    #menu-btn {
      font-size: 12px;
      padding: 4px 8px;
    }

    #controls {
      margin-top: 5px; /* Reduced margin */
    }

    .control-btn {
      width: 35px; /* Slightly smaller buttons */
      height: 35px;
      font-size: 14px;
      margin: 5px;
    }
  }

  /* Add a new media query for very small screens */
  @media (max-width: 320px) {
    #game-container {
      max-height: 55vh;
    }

    #controls {
      flex-wrap: wrap;
      justify-content: space-around;
    }

    .control-btn {
      width: 30px;
      height: 30px;
      font-size: 12px;
      margin-bottom: 5px;
    }
  }

  /* Adjust the layout for landscape orientation */
  @media (max-width: 767px) and (orientation: landscape) {
    #game-container {
      max-height: 80vh;
      max-width: 50%;
      float: left;
    }

    #controls {
      float: right;
      width: 45%;
      flex-direction: column;
      align-items: center;
    }

    .control-btn {
      margin: 5px 0;
    }
  }

  /* Fine-tune for larger screens */
  @media (min-width: 768px) and (max-width: 1024px) {
    #game-container {
      max-width: 80%;
    }
  }

  /* Ensure full-screen menu on all devices */
  .menu-content, .settings-content {
    width: 100%;
    height: 100%;
    max-width: none;
    max-height: none;
    box-sizing: border-box;
    padding: 5%;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .fade-in {
    animation: fadeIn 0.3s ease-in-out;
  }

  #drop-btn {
    background-color: #ff6b6b;
  }

  #drop-btn:hover {
    background-color: #ff8787;
  }

</style>
</head>
<body>
  <div id="menu-overlay" class="overlay">
    <div class="menu-content">
      <h1 data-translate="title">Tetris WebSim</h1>
      <button id="play-btn" class="menu-btn" data-translate="play">Play</button>
      <button id="settings-btn" class="menu-btn" data-translate="settings">Settings</button>
      <div id="high-score"><span data-translate="highScore">High Score</span>: 0</div>
    </div>
  </div>

  <div id="settings-panel" class="overlay">
    <div class="settings-content">
      <h2 data-translate="settings">Settings</h2>
      <div class="setting">
        <label for="color-palette" data-translate="colorPalette">Color Palette:</label>
        <select id="color-palette">
          <option value="default">Default</option>
          <option value="pastel">Pastel</option>
          <option value="neon">Neon</option>
        </select>
      </div>
      <div class="setting">
        <label for="language" data-translate="language">Language:</label>
        <select id="language">
          <option value="en">English</option>
          <option value="es">Espa침ol</option>
        </select>
      </div>
      <button id="save-settings" class="menu-btn" data-translate="saveClose">Save & Close</button>
    </div>
  </div>

  <div id="game-container">
    <canvas id="game-board"></canvas>
    <div id="score"><span data-translate="score">Score</span>: 0</div>
    <div id="timer"><span data-translate="time">Time</span>: 00:00</div>
    <div id="moves"><span data-translate="moves">Moves</span>: 0</div>
    <div id="next-piece-container">
      <canvas id="next-piece"></canvas>
    </div>
    <button id="menu-btn">Menu</button>
  </div>

  <div id="controls">
    <button class="control-btn" id="left-btn">&#8592;</button>
    <button class="control-btn" id="rotate-btn">&#8635;</button>
    <button class="control-btn" id="right-btn">&#8594;</button>
    <button class="control-btn" id="down-btn">&#8595;</button>
    <button class="control-btn" id="drop-btn">&#8681;</button>
  </div>

<script>
const canvas = document.getElementById('game-board');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const timerElement = document.getElementById('timer');
const movesElement = document.getElementById('moves'); // New moves element
const nextPieceElement = document.getElementById('next-piece');
const nextPieceCtx = nextPieceElement.getContext('2d');
const menuBtn = document.getElementById('menu-btn');
let gameActive = true;

const COLS = 10;
const ROWS = 20;
let BLOCK_SIZE = 30;

canvas.width = COLS * BLOCK_SIZE;
canvas.height = ROWS * BLOCK_SIZE;

ctx.scale(BLOCK_SIZE, BLOCK_SIZE);

const colorPalettes = {
  default: [
    '#FF6B6B', '#4ECDC4', '#45B7D1', '#F9C74F', 
    '#90BE6D', '#43AA8B', '#577590', '#F94144',
    '#F3722C', '#F8961E', '#F9844A', '#F9C74F',
    '#277DA1', '#4D908E'
  ],
  pastel: [
    '#FFB3BA', '#FFDFBA', '#FFFFBA', '#BAFFC9', '#BAE1FF',
    '#FFC6FF', '#BDB2FF', '#A0C4FF', '#9BF6FF', '#CAFFBF'
  ],
  neon: [
    '#FF00FF', '#00FFFF', '#00FF00', '#FFFF00', '#FF0000',
    '#FF1493', '#00FA9A', '#1E90FF', '#FF4500', '#FFD700'
  ]
};

let COLORS = [...colorPalettes.default];

const SHAPES = [
  [[1, 1, 1, 1]],                         
  [[1, 1, 1, 1, 1]],                      
  [[1, 1], [1, 1]],                       
  [[1, 1, 1], [0, 1, 0]],                 
  [[1, 1, 1], [1, 0, 0]],                 
  [[1, 1, 1], [0, 0, 1]],                 
  [[1, 1, 0], [0, 1, 1]],                 
  [[0, 1, 1], [1, 1, 0]],                 
  [[1, 1, 1, 1], [0, 0, 1, 0]],           
  [[1, 1, 1], [1, 0, 1]],                 
  [[1, 1], [1, 0], [1, 0]],               
  [[1, 1, 1], [1, 1, 1], [1, 1, 1]],      
  [[1, 0, 0], [1, 1, 1], [0, 0, 1]]       
];

let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
let score = 0;
let moves = 0; // New moves variable
let currentPiece = getRandomPiece();
let nextPiece = getRandomPiece();
let dropCounter = 0;
let dropInterval = 800;
let lastTime = 0;
let gameTime = 0;

let highScore = 0;
let currentColorPalette = 'default';

const translations = {
  en: {
    title: "Tetris WebSim",
    play: "Play",
    settings: "Settings",
    highScore: "High Score",
    colorPalette: "Color Palette",
    language: "Language",
    saveClose: "Save & Close",
    score: "Score",
    time: "Time",
    moves: "Moves"
  },
  es: {
    title: "Tetris WebSim",
    play: "Jugar",
    settings: "Ajustes",
    highScore: "Puntuaci칩n M치xima",
    colorPalette: "Paleta de Colores",
    language: "Idioma",
    saveClose: "Guardar y Cerrar",
    score: "Puntuaci칩n",
    time: "Tiempo",
    moves: "Movimientos"
  }
};

function getRandomPiece() {
  const randomShape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
  const color = COLORS[Math.floor(Math.random() * COLORS.length)];
  return { shape: randomShape, color, row: 0, col: Math.floor(COLS / 2) - Math.ceil(randomShape[0].length / 2) };
}

function getGhostPiecePosition() {
  const ghost = JSON.parse(JSON.stringify(currentPiece));
  while (!collision(ghost)) {
    ghost.row++;
  }
  ghost.row--;
  return ghost;
}

function dropPiece() {
  while (!collision()) {
    currentPiece.row++;
  }
  currentPiece.row--;
  merge();
  clearLines();
  currentPiece = nextPiece;
  nextPiece = getRandomPiece();
  updateNextPieceDisplay();
  if (collision()) {
    gameOver();
  }
}

function moveDown() {
  currentPiece.row++;
  if (collision()) {
    currentPiece.row--;
    merge();
    clearLines();
    currentPiece = nextPiece;
    nextPiece = getRandomPiece();
    updateNextPieceDisplay();
    if (collision()) {
      gameOver();
    }
  }
}

function drawBoard() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.fillRect(0, 0, COLS, ROWS);

  ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
  ctx.lineWidth = 0.05;

  for (let i = 0; i <= COLS; i++) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, ROWS);
    ctx.stroke();
  }

  for (let i = 0; i <= ROWS; i++) {
    ctx.beginPath();
    ctx.moveTo(0, i);
    ctx.lineTo(COLS, i);
    ctx.stroke();
  }

  board.forEach((row, y) => {
    row.forEach((block, x) => {
      if (block) {
        ctx.fillStyle = COLORS[block.value - 1];
        ctx.globalAlpha = block.isNew ? 0 : 1;
        ctx.fillRect(x, y, 1, 1);
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.strokeRect(x, y, 1, 1);
        ctx.globalAlpha = 1;
        
        if (block.isNew) {
          block.isNew = false;
          animateBlock(x, y);
        }
      }
    });
  });
}

function animateBlock(x, y) {
  let opacity = 0;
  const animationInterval = setInterval(() => {
    opacity += 0.1;
    if (opacity >= 1) {
      clearInterval(animationInterval);
    }
    board[y][x].opacity = opacity;
  }, 30);
}

function merge() {
  currentPiece.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        const blockValue = COLORS.indexOf(currentPiece.color) + 1;
        board[currentPiece.row + y][currentPiece.col + x] = {
          value: blockValue,
          isNew: true
        };
      }
    });
  });
  moves++; // Increment moves when a piece is merged
  updateMoves();
}

function clearLines() {
  let linesCleared = 0;
  board = board.reduce((acc, row) => {
    if (row.every(value => value !== 0)) {
      linesCleared++;
      acc.unshift(Array(COLS).fill(0));
    } else {
      acc.push(row);
    }
    return acc;
  }, []);

  if (linesCleared > 0) {
    score += linesCleared * 100;
    updateScore();
    playLineClearAnimation(linesCleared);
  }
}

function playLineClearAnimation(linesCleared) {
  const gameContainer = document.getElementById('game-container');
  gameContainer.classList.add('glow');
  setTimeout(() => {
    gameContainer.classList.remove('glow');
  }, 500);
}

function updateScore() {
  scoreElement.textContent = 'Score: ' + score;
}

function updateMoves() {
  movesElement.textContent = `Moves: ${moves}`; // Update the moves display
}

function updateTimer() {
  const minutes = Math.floor(gameTime / 60000);
  const seconds = Math.floor((gameTime % 60000) / 1000);
  timerElement.textContent = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

function updateNextPieceDisplay() {
  nextPieceCtx.clearRect(0, 0, nextPieceElement.width, nextPieceElement.height);
  
  const scale = 20;
  nextPieceCtx.save();
  nextPieceCtx.scale(scale, scale);
  
  const offsetX = (4 - nextPiece.shape[0].length) / 2;
  const offsetY = (4 - nextPiece.shape.length) / 2;
  
  drawPiece(nextPiece, nextPieceCtx, offsetX, offsetY);
  
  nextPieceCtx.restore();
}

function gameOver() {
  gameActive = false;
  updateHighScore();
  showMenu();
}

function restartGame() {
  board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
  score = 0;
  gameTime = 0; 
  dropCounter = 0;
  moves = 0; // Reset moves
  currentPiece = getRandomPiece();
  nextPiece = getRandomPiece();
  updateScore();
  updateMoves(); // Update moves display on restart
  updateTimer();
  updateNextPieceDisplay();
  dropInterval = 800; 
}

function showMenu() {
  document.getElementById('menu-overlay').style.display = 'flex';
  gameActive = false;
  gameTime = 0; 
  updateTimer(); 
  restartGame(); 
}

function hideMenu() {
  document.getElementById('menu-overlay').style.display = 'none';
  gameActive = true;
  restartGame(); 
  lastTime = performance.now(); 
  requestAnimationFrame(update); 
}

function showSettings() {
  document.getElementById('settings-panel').style.display = 'flex';
  updateLanguage(); // Update language when showing settings
}

function hideSettings() {
  document.getElementById('settings-panel').style.display = 'none';
}

function updateHighScore() {
  if (score > highScore) {
    highScore = score;
    document.getElementById('high-score').textContent = `High Score: ${highScore}`;
  }
}

function changeColorPalette() {
  currentColorPalette = document.getElementById('color-palette').value;
  COLORS.length = 0;
  colorPalettes[currentColorPalette].forEach(color => COLORS.push(color));
  updateNextPieceDisplay();
}

function updateLanguage() {
  const lang = document.getElementById('language').value;
  document.querySelectorAll('[data-translate]').forEach(element => {
    const key = element.getAttribute('data-translate');
    element.textContent = translations[lang][key];
  });
}

document.addEventListener('keydown', event => {
  if (!gameActive) return;
  
  switch (event.keyCode) {
    case 37: 
      moveLeft();
      break;
    case 39: 
      moveRight();
      break;
    case 40: 
      moveDown();
      break;
    case 38: 
      rotate();
      break;
    case 32: 
      dropPiece();
      break;
  }
});

// Touch controls
document.getElementById('left-btn').addEventListener('click', () => {
  if (gameActive) moveLeft();
});
document.getElementById('right-btn').addEventListener('click', () => {
  if (gameActive) moveRight();
});
document.getElementById('down-btn').addEventListener('click', () => {
  if (gameActive) moveDown();
});
document.getElementById('rotate-btn').addEventListener('click', () => {
  if (gameActive) rotate();
});

// Drop button
document.getElementById('drop-btn').addEventListener('click', () => {
  if (gameActive) dropPiece();
});

// Menu button
menuBtn.addEventListener('click', showMenu);

// Menu buttons
document.getElementById('play-btn').addEventListener('click', () => {
  hideMenu();
  restartGame(); 
});
document.getElementById('settings-btn').addEventListener('click', showSettings);
document.getElementById('save-settings').addEventListener('click', () => {
  changeColorPalette();
  updateLanguage();
  hideSettings();
});

// Remove music-related code
function collision(piece = currentPiece) {
  return piece.shape.some((row, dy) => {
    return row.some((value, dx) => {
      if (value !== 0) {
        const x = piece.col + dx;
        const y = piece.row + dy;
        return x < 0 || x >= COLS || y >= ROWS || (y >= 0 && board[y][x] !== 0);
      }
      return false;
    });
  });
}

function moveLeft() {
  currentPiece.col--;
  if (collision()) {
    currentPiece.col++;
  }
}

function moveRight() {
  currentPiece.col++;
  if (collision()) {
    currentPiece.col--;
  }
}

function rotate() {
  const originalShape = currentPiece.shape;
  currentPiece.shape = currentPiece.shape[0].map((_, i) =>
    currentPiece.shape.map(row => row[i]).reverse()
  );
  if (collision()) {
    currentPiece.shape = originalShape;
  }
}

function drawGhostPiece() {
  const ghost = getGhostPiecePosition();
  ctx.globalAlpha = 0.3;
  drawPiece(ghost, ctx);
  ctx.globalAlpha = 1;
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBoard();
  drawGhostPiece();
  drawPiece(currentPiece, ctx);
}

function drawPiece(piece, context, offsetX = 0, offsetY = 0) {
  piece.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value !== 0) {
        context.fillStyle = piece.color;
        context.fillRect(piece.col + x + offsetX, piece.row + y + offsetY, 1, 1);
        context.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        context.strokeRect(piece.col + x + offsetX, piece.row + y + offsetY, 1, 1);
      }
    });
  });
}

// Show the menu when the page loads
window.addEventListener('load', () => {
  showMenu();
  updateLanguage();
  resizeGame();
});

function resizeGame() {
  const container = document.getElementById('game-container');
  const containerWidth = container.clientWidth;
  const containerHeight = container.clientHeight;
  
  canvas.width = containerWidth;
  canvas.height = containerHeight;
  
  BLOCK_SIZE = containerWidth / COLS;
  
  ctx.scale(BLOCK_SIZE, BLOCK_SIZE);
  
  draw();

  // Show controls on mobile devices
  const controls = document.getElementById('controls');
  if (window.innerWidth <= 767) {
    controls.style.display = 'flex';
  } else {
    controls.style.display = 'none';
  }
}

// Call resizeGame on page load and window resize
window.addEventListener('load', resizeGame);
window.addEventListener('resize', resizeGame);

function update(time = 0) {
  if (!gameActive) return;

  const deltaTime = time - lastTime;
  lastTime = time;

  gameTime += deltaTime;
  updateTimer();

  dropCounter += deltaTime;
  if (dropCounter > dropInterval) {
    moveDown();
    dropCounter = 0;
  }

  draw();
  requestAnimationFrame(update);
}

updateNextPieceDisplay();
updateMoves(); // Call updateMoves in the initial setup
update();
</script>
</body>
</html>